= Presentation =

OCL2ACSL translates OCL constraints expressed for UML operations into ACSL contracts that are meant to annotate C functions implementing these operations.
The entry point of the generator is the org.eclipse.ocl2acsl.Ocl2acsl class. It provides methods that parse OCL constraints and produce an Abstract Syntax Tree. The org.eclipse.ocl2acsl.OCLVisitor class provides a visitor that navigates into the tree and translates the OCL nodes. 


= Ocl2acsl class =

The provided constructor Ocl2acsl( ) sets up the environment for OCL translation. Methods in this class translate OCL constraints of type org.eclipse.uml2.uml.Constraint into string representations of the corresponding ACSL expressions. The class also explores the operations of the model that are objects of type org.eclipse.uml2.uml.Operation in order to generate contract clauses stating the validity of pointers and arrays and the memory locations the operation is allowed to modify.

<code language="java">String prepost2acsl(Constraint cons)</code> Generates the ACSL expression that corresponds to the given pre/post condition
<code language="java">String inv2acsl(Constraint cons)</code> 
Generates an ACSL expression equivalent to the given OCL invariant

<code language="java">ArrayList <String> generateValidClauses (Operation op) </code> Returns a list of ACSL valid clauses corresponding to the pointers introduced to represent modifiable parameters

<code language="java">ArrayList<String> getAssignedParameters (Operation op) </code> Returns a list of parameters’ names that correspond to the parameters the operation is allowed to modify

<code language="java">ArrayList<String> generateArrayValidClauses (Operation op)</code> Returns a list of ACSL valid clauses corresponding to the arrays manipulated by the operation

These methods instantiate an OCLVisitor that explores the constraint and returns the resulting ACSL expression. More details on the translation can be found in the table at the end of this wiki.

= ACCELEO module =

Ocl2acsl methods require constraints defined in the context of a class diagram. Therefore, in order to use the generator, we have to parse the UML model. The ACCELEO module OCL2ACSL parses the model and generates for each class a ".fc" file containing the contracts of all its operations. 

*StaticOcl2ACSL*: This class is used to link the ACCELEO module and the OCL2ACSL tool. It instantiates an OCL2acsl object and provides static methods to perform the translation.

*Wrapper*: A wrapper “wrapper.mtl” is provided to invoke the java methods for translation. For example, the prepost2acsl method is wrapped into an ACCELEO query as follows:

<img src="https://svn.codespot.com/a/eclipselabs.org/ocl2acsl/wiki/wrapper.png" height="100" width="500"/>

 
*Generator*: The “generate.mtl” file parses the model and generates for each class a “.fc” file containing the different contracts.

<img src="https://svn.codespot.com/a/eclipselabs.org/ocl2acsl/wiki/generator.PNG" height="200" width="500"/>

A contract contains four different parts:
  * Valid clauses: They express which pointers are required to be valid before the execution of the method,  and are generated using getValidClauses( )

  * Requires clauses: Pre-conditions of the operation, generated using getPre( ) 

  * Assigns clauses: Memory locations the operation is allowed to modify, generated using getAssignsClauses( )

  * Ensures clauses: Post-conditions of the operation, generated using getPost( ) 

These three templates invoke the wrapper’s queries and add the corresponding ACSL keywords to the result. Below is how getPre() works :

<img src="https://svn.codespot.com/a/eclipselabs.org/ocl2acsl/wiki/getpre.PNG" height="100" width="500"/>

= An example =

Let’s consider the following class diagram: 

<img src="https://svn.codespot.com/a/eclipselabs.org/ocl2acsl/wiki/wiki.png"/>

We run the ACCELEO module by running the project as an ACCELEO application and by providing the path to the model and the destination of the generated files. 

<img src="https://svn.codespot.com/a/eclipselabs.org/ocl2acsl/wiki/acceleo.png" height="500" width="600"/>

The tool generates the corresponding Wiki.fc file:

<img src="https://svn.codespot.com/a/eclipselabs.org/ocl2acsl/wiki/fc.png"/>

= Rules and assumptions for translation =

|| *OCL expression* || *Details* || *Remarks and assumptions* || *Implementation* ||
|| PropertyCallExp || Attribute access || Assumption: A property of type T is translated to a field of type T. A collection property is translated <br> to a pointer field T`*` if it has a variable size, to an array T`[`n`]` otherwise.  If the size is variable, the struct <br> must also own a property of type int named size`_`{name`_`array} indicating the size of the array. <br> If it is constant, it must be defined using a macro named CLASS_PROP_SIZE ||<code>(*obj).id / (*obj).array[i]</code>||
|| || Composition || Assumption : Same assumption || <code>(*obj1).obj2.id / (*obj1).objArray`[`i].id </code>||
|| || Aggregation || Assumption: An aggregation of type T is translated to a pointer field of type T`*`. If it has a multiplicity of n, <br> it is translated to an array of pointers of size n. Otherwise, if it has a variable size it is translated to a <br> pointer on pointers.  Same assumptions for the sizes. || <code>(*(*obj1).obj2).id / (*(*obj1).objArray[i]).id </code> ||
|| || PRE label	|| || <code>\old </code> ||
|| OperationCallExp || or / xor/ and/ not/ implies || On booleans || <code>`|``|` / ^^ / && / ! /  ==> </code>||
|| || +/- || On integers/reals ||<code>+/-</code>||
|| || *// || On integers/reals || <code>*//</code>||
|| || < > <= >= || On integers/reals ||<code>< > <= >= </code>||
|| || Min/Max || On integers/reals ||<code>\Min \Max</code>||
|| || Mod || On integers ||<code>%</code>||
|| || abs || On reals ||<code>Abs</code>||
|| || a->First()/last || ||<code>a[0] a[size_a-1]</code>||
|| || a->at(i)|| ||<code>a[i]</code>||
|| || Includes(e) || The source of the operator must be one of the following: || ||	
|| || || 1- An array that is a parameter of the operation ||<code>\exists int i;  0 <= i <= size_a-1 && a[i]=e</code>||
|| || || 2- A property that is an array ||<code>\exists int i;  0 <= i <= obj.size_prop-1 && obj.prop[i]=e</code>||
|| || || If the array is of variable size, the operation or the owning type must have a parameter or a field <br> indicating the size and named size`_`{name`_`array}. If the size is constant, it must be defined <br> using a macro named OPER_PARAM_SIZE || ||	 
|| || Excludes(obj) || Idem (a is either a parameter or a property) ||<code>\forall int i;  0 <= i <= size_a-1 ==> a[i]!=e</code>||
|| || <> on collections a,b || Idem (a,b are either parameters or properties) || <code>size_a!=size_b </code><code>`|``|` \exists int i;  0 <= i <= size_a-1 && a[i]!=b[i]</code>||
|| || "=" on collections a,b || Idem (a,b are either parameters or properties) || <code>size_a==size_b</code><code>&& \forall int i;  0 <= i <= size_a-1 ==> a[i]=b[i]</code>||
|| || IncludesAll a,b || Idem (a,b are either parameters or properties) || <code>\forall int i;  0 <= i <= size_b-1</code><code>==> \exists int j;  0 <= j <= size_a-1 && a[j]=b[i]</code>||
|| || ExcludesAll a,b || Idem (a,b are either parameters or properties)	||<code>\forall int i;  0 <= i <= size_b-1</code><code>==> \forall int j;  0 <= j <= size_a-1 ==> a[j]!=b[i]</code>||
|| || isEmpty || Idem (a is either a parameter or a property) || <code>size_a = 0</code>||
|| || notEmpty || Idem (a is either a parameter or a property) || <code>size_a != 0</code>||
|| || size || Idem (a is either a parameter or a property) || <code>size_a</code>||
|| IteratorExp || Forall || The source of the operator must be one of the following: || ||	 
|| || || 1- A sequence of integers n1..n2 that indexes an array in the body of the forAll || <code>\forall int i; n1 <= i <= n2 ==> body(a[i]);</code>||
|| || || 2- An array that is a parameter of the operation || <code>\forall int i; 0 <= i <= size_a-1 ==> body(a[i]);</code>||
|| || || 3- A property that is an array || <code>\forall int i; 0 <= i <= obj.size_prop-1 ==> body(obj.prop[i]);</code>||
|| || || If the array is of variable size, the operation or the owning type must have a parameter or a field <br> indicating the size and named size_{name_array}. If the size is constant, it must be defined using a macro. || ||	 
|| || Exists || Idem || Idem with \exists ||
|| || One || The source of the operator must be one of the following: || ||	 
|| || || 1- An array that is a parameter of the operation || <code>(\exists int i; 0<=i<=size_a-1 && f(a[i]))</code><code> && (\forall int j; 0<=j<=size_a-1 && j!=i ==> !f(a[i])</code>||
|| || || 2- A property that is an array ||<code>(\exists int i; 0<=i<=obj.size_prop-1 && f(obj.prop[i]))</code><code>&& (\forall int j; 0<=j<=obj.size_prop-1 && j!=i ==> !f(obj.prop[i])</code> ||
|| || || Same assumptions for the sizes || ||	 
|| VariableExp || Parameter || Assumption: All parameters of primitive types and that are OUT or INOUT, are transformed into <br> pointers. Parameters of user-defined types are always transformed into pointers. || Generation of assigns clauses for modifiable parameters and valid clauses <br> for pointers and arrays. ||
|| || Result || ||<code>\result</code>|| 
|| IfExp || || ||<code>condition?x:y</code>||
|| LetExp || || ||<code>\let id=exp;body;</code>||